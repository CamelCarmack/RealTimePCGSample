#include "/Engine/Public/Platform.ush"

struct FScatterPoint
{
    float LocationX;
    float LocationY;
};
RWStructuredBuffer<uint> InstanceCountBuffer;
float2 InputPattern[64];
float2 PatternSize;
uint PatternPointNum;
Texture2D<float> InputTexture;
Texture2D<float> PlacementSDF;
Texture2D<float> InputSDF;
RWTexture2D<float> OutputSDF;
SamplerState LinearSampler;
uint2 CenterOffset;
float4 TotalRect;
float4 ClipRect;
float Ratio;
float RadiusScale;
uint FlipY;
RWStructuredBuffer<FScatterPoint> OutputPointCloud;


uint2 GetCenterID(uint3 Gid)
{
    return Gid.xy + CenterOffset;
}
bool InRect(float2 Pos,float4 Rect)
{
    if (Pos.x < Rect.x || Pos.x >= Rect.z || Pos.y < Rect.y || Pos.y >= Rect.w)
    {
        return true;
    }
    else
    {
        return false;
    }
}
[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainComputeShader(uint3 Gid : SV_GroupID, //atm: -, 0...256, - in rows (Y)        --> current group index (dispatched by c++)
                       uint GI : SV_GroupIndex)            //atm: 0...256 in columns (X)           --> "flattened" index of a thread within a group))
{
    uint2 centerID = GetCenterID(Gid);
    float2 center = float2(centerID.x, centerID.y);
    uint k = GI;
    uint3 hashSeed = uint3(centerID.x, centerID.y, k);
    if (k >= PatternPointNum)
        return;
    
    float2 rectSize = TotalRect.zw - TotalRect.xy;
    
    float2 pos = (center * PatternSize + InputPattern[k]) * RadiusScale;
    
    float2 uv = pos / rectSize;
    if (FlipY)
        uv = 1 - uv.y;
    pos += TotalRect.xy;
    
    if (InRect(pos, TotalRect))
    {
        return;
    }
    
    float r = saturate(InputTexture.SampleLevel(LinearSampler, uv, 0));
    float placementSDF = PlacementSDF.SampleLevel(LinearSampler, uv, 0);
    float collisionSDF = saturate(InputSDF.SampleLevel(LinearSampler, uv, 0));
    
    float hash1 = frac(dot(hashSeed.zyy * (hashSeed.xxy + float3(43.1275, 11.418, -17.1634)) / 3.91, float3(12.739, 3.1415926, 35.12)));
    float hash2 = frac(dot(hashSeed.xyz * (hashSeed.zxy + float3(2.17501, 69.175501, 109.345)) / 1.73, float3(20.390625, 60.703125, 2.4281209)));
    
    uint curindex;
    uint2 sdfSize;
    OutputSDF.GetDimensions(sdfSize.x, sdfSize.y);
    FScatterPoint res;
    if (r > hash1 && hash2 < Ratio && collisionSDF > 0 && placementSDF > 100 * RadiusScale)
    {
        
        OutputSDF[sdfSize * uv] = 100 * RadiusScale;
        if (InRect(pos, ClipRect))
        {
            return;
        }
        InterlockedAdd(InstanceCountBuffer[0], 1, curindex);
        res.LocationX = pos.x;
        res.LocationY = pos.y;
        OutputPointCloud[curindex] = res;
        
    }
    
    
}